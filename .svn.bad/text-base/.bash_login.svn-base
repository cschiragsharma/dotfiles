SSH_AGENT_PID=""

# If not running interactivly, lets bugger off
[ -z "$PS1" ] && return
# if we already set things up lets do it again
[ ! -z "$LOGGED_IN" ] && return

if [[ -e ~/bin/sync_links.sh ]]; then
	~/bin/sync_links.sh
fi

trap "echo No ^C here" INT TERM EXIT

# check if we have a running AUTH SOCK
if [[ ( ! -z $SSH_AUTH_SOCK ) && -e $SSH_AUTH_SOCK && -S $SSH_AUTH_SOCK ]]; then
	# tunneld AUTH and we have an identitiy file so add it  
	echo "export SSH_AUTH_SOCK=$SSH_AUTH_SOCK" > ~/.ssh_agent.sh
	if [[ -z $SSH_AGENT_PID && -e ~/.ssh/id_rsa ]]; then
		ssh-add
	fi
# check if a previous session has started an agent
elif [[ -e ~/.ssh_agent.sh ]]; then
	. ~/.ssh_agent.sh
fi

# we have login in over ssh 
if [[ ! -z $SSH_TTY ]]; then
	DO_SCREEN=1
fi

# use : as a delminator the ssh command in ~/bin will increment teh SCEREEN_LEVEL and comboulate the TERM when sshing
SCREEN_LEVEL=${TERM#*:}
TERM=${TERM%:*}
if [[ $SCREEN_LEVEL = $TERM ]]; then
	unset SCREEN_LEVEL
fi
# source addtional based on TERM
if [[ -e ~/.bash_login.${TERM} ]]; then
	. ~/.bash_login.${TERM}
else
	now=`date  +"%d-%m-%Y %H:%M"`
	echo "$now $TERM" >> ~/log/login.terms
fi

trap - INT TERM EXIT

LOGGED_IN=1

export LOGGED_IN SCREEN_LEVEL TERM
if [[ ! -z $DO_SCREEN ]]; then
	screen -d -RR
fi

# for the moment lets not do fancy ssh-agent stuffs
return

#redo=1
#
#while [ $redo != 0 ]
#do
#	if [[ -z $SSH_AGENT_PID || ! -d /proc/$SSH_AGENT_PID ]]; then
#		ssh-agent -s > ~/.ssh_agent.sh
#		. ~/.ssh_agent.sh
#		ssh-add
#		if [[ $? == 0 ]]; then
#			redo=0
#		else
#			echo "FAIL: Try again"
#		fi
#	else 
#	# ssh-agent allready running nuke the key and make us re-enter the password
#		ssh-add -d 2>/dev/null
#		ssh-add
#		if [[ $? == 0 ]]; then
#			redo=0
#		else
#			echo "FAIL: Try again"
#		fi
#	fi
#done
#if [[ $redo == 0 ]]; then
#	screen -d -RR
#fi

# vim: ft=sh
